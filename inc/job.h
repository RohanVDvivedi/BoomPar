#ifndef JOB_H
#define JOB_H

#include<pthread.h>
#include<promise.h>

// a job can be in any of the following states
typedef enum job_state job_state;
enum job_state
{
	CREATED,
	RUNNING,
	COMPLETED,
	CANCELLED
};

/*
	State transitions:

	CREATED -> RUNNING -> COMPLETED (can be deleted)
	   |
	   +-----> CANCELLED (can be deleted)

	* Only a CREATED job can be cancelled
*/

/*
	All the functions of the job are thread unsafe,
	So only one pointer to a particular job must exist in your system.
	This implies that only 1 thread must be allowed to call functions on a job.
*/

typedef struct job job;
struct job
{
	job_state state;

	// pointer to the input pramameter, 
	void* input_p;

	// the function pointer that will be executed with input parameter
	void* (*job_function)(void* input_p);

	// this function pointer that will be called upon cancellation of this job, with the job's input parameter (This can be used for clean up upon cancellation of the job)
	void (*cancellation_callback)(void* input_p);

	// The cancellation_callback can be used by the user to free the resources held by input_p, in case when the user decides to not execute the job

	// both the above functions use the job->input_p as their parameter

	// set_promised_result will be called on this promise with the output generated by the job on executuion of the job
	promise* promise_for_output;
};

// A job can be created/initialized with promise_for_output,
// in that case other threads can wait to receive output of the job by calling get_promised_result on that promise
// It is an optional parameter and can be NULL

// Note: a job can be linked to only a promise and a promise can be linked to only a specific job

// A job can be created/initialized with calcellation_callback,
// this is the function that gets called when a job is cancelled,
// It can be used to free up resources reserved by input_p, in case a job does not get called
// It is an optional paramater and can be NULL

job* new_job(void* (*function_p)(void* input_p), void* input_p, promise* promise_for_output, void (*cancellation_callback)(void* input_p));

void initialize_job(job* job_p, void* (*function_p)(void* input_p), void* input_p, promise* promise_for_output, void (*cancellation_callback)(void* input_p));

// executes the given job, in async, on a new thread (job must be in CREATED state)
// returns error code returned by the pthread_create, 0 for success
int execute_job_async(job* job_p, pthread_t* thread_id);

// executes the given job on the same thread (job must be in CREATED state)
// returns 0 if the job was executed, else returns -1 for failure
int execute_job(job* job_p);

// cancels a CREATED job
// 0 implies success, -1 is failure
int cancel_job(job* job_p);

// to deinitialize or delete a job it must be in CANCELLED or COMPLETED state

void deinitialize_job(job* job_p);

void delete_job(job* job_p);

#endif 