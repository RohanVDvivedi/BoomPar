PROMISE_DATA
 * implement as a sync queue, and adds its own callback to all the promises and you can wait on it until n promises are ready for you to consume and promised results are returned as an cutlery array

JOB
 * add WAIT as a job state
 * use linux api of user context to allow separate stacks for jobs

SYNC_JOB_STREAM
 * implement sync_stream api, using pthread_spin_lock

EXECUTOR
 * create a job waiters hashtable where they can wait in the executor on sync_stream or a timer
 * wake_one and wake_all calls to wake jobs that are waiting on a sync stream

WORKER
 * use callbacks in the worker, and pass then from executor
 * reduce the stack size of worker threads saving memory

FUTURE
 * provide smart_pointer
 * yield(time_period_in_nano_seconds) allows a running job to go on a wait, 0 implies a voluntary relinquish of cpu, we will need a job timer heap
