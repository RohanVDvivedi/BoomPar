PROMISE_DATA
 * think how to destroy a promise, thinks like single callback, callback passing promise instead of its result, fortify concept of what gets passed to callback params, etc, OR in worst case make promise reference counted, mainly make promise deletable right after use.

JOB
 * add WAIT as a job state
 * use linux api of user context to allow separate stacks for jobs

SYNC_JOB_STREAM
 * implement sync_stream api, using pthread_spin_lock

EXECUTOR
 * create a job waiters hashtable where they can wait in the executor on sync_stream or a timer
 * wake_one and wake_all calls to wake jobs that are waiting on a sync stream

WORKER
 * use callbacks in the worker, and pass then from executor
 * reduce the stack size of worker threads saving memory

FUTURE
 * provide smart_pointer
 * yield(time_period_in_nano_seconds) allows a running job to go on a wait, 0 implies a voluntary relinquish of cpu, we will need a job timer heap
