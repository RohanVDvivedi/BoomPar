SMART_POINTER
 * smart_pointer type stores allocator, initializer and deinitializer functions
 * pointer that deletes what ever it is pointing to after its reference counter reaches 0
 * api like: smart_pointer create_smart_pointer(const smart_pointer_type*), void* get_data_value(const smart_pointer*), smart_pointer duplicate_smart_pointer(const smart_pointer*) and int destroy_smart_pointer(smart_pointer*) /* destroy returns true if this call freed the data value memory */.
 * it stores pointer to concurrent reference counter and pointer to actual data (a deinitialized/destroyed or a NULL smart_pointer will have both the values NULL)
 * concurrent reference counter stores an a mutex lock, an unsigned long long int reference counter, pointer to the smart_pointer_type

SYNC_COROUTINE_PIPE
 * implement sync_coroutine_pipe api like the sync_queue without non_blocking access

COROUTINE
 * COROUTINE_EXECUTOR - a duplicate of fixed thread count executor but to run only coroutines, it starts all threads at once
 * COROUTINE - a wrapper for functions with void func(void* param)
