 * implement a class called resource_tokenizer
 * stores a mutex, a condition variable and a counter for the resources_allocated and resource_given out
 * api:
   * int set_resource_count(uint64_t resources_allocated) // increase or decrease the number of resources
   * uint64_t grant_resource(uint64_t requirement, uint64_t timeout_in_microseconds, int* condition_check);
   * uint64_t grant_resource_partial_allowed(uint64_t requirement, uint64_t timeout_in_microseconds, int* condition_check); // grant atmost requirement number of resources, blocks only for 0 resources available
   * set_grantee_condition_checks(int* condition_check, int condition_check_value); // broadcast all waiters to wake up and check their condition_check values, if they change that grantee wakes up and quits
   * condition_check's value is cached by the grant_resource functions right after they begin, and gets compared right after they wake_up spuriously or on a broadcast
   * condition_check variable is a way for telling the grantee that they not wait any longer, it should be always set using the set_grantee_condition_checks() function
   * grant resource function return immediately if requirement == 0
   * uint64_t give_back_resource(uint64_t replenishment, uint64_t timeout_in_microseconds);
   * along with initialize and deinitialize functions